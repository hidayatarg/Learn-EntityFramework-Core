# Entity Framework Core Web App
This is a Web app for learning the entityFrameworkCore

## Install the package
Istall Microsoft.EntityFrameworkCore.SqlServer. We will use MS SQL Serve for the database.

Here We connected to the database via the database string that is placed in the `appsettings.json` as the `DefaultConnection`.
```sh
{
  "ConnectionStrings": {
	"DefaultConnection": "Server=(localdb)\\mssqllocaldb;Database=EfCoreWebApp;Trusted_Connection=True;MultipleActiveResultSets=True"
  },

  "Logging": {
	"IncludeScopes": false,
	"LogLevel": {
	  "Default": "Warning"
	}
  }
}
```

## What is a Database Context
DB context is simply a class that helps to reach your database throught that class.
It is inherited from the DbContext class of EntityFrameworkCore.

## Create the models/tables
Contact class
```csharp
public class Contact: BaseEntity
{
	public string FirstName { get; set; }
	public string LastName { get; set; }
	public string Email { get; set; }
}

```
ToDo class
```csharp
public class ToDo:BaseEntity
{
	public string Text { get; set; }
	public bool Completed { get; set; }
}

```
BaseEntity Class
```csharp
public class BaseEntity
{
	public int Id { get; set; }
}
```
in the AppDbContext class the two lines with Dbset will tell entity framework to generate two tables
```csharp
public class AppDbContext:DbContext
{
	public AppDbContext(DbContextOptions<AppDbContext> options): base(options)
	{
			
	}

	public DbSet<Contact> Contacts { get; set; }
	public DbSet<ToDo> ToDos { get; set; }
}
```

## Creating the database
In startup.cs we need to add the following using namespaces
```csharp
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Extensions;

 //And the Register our DbContext
public void ConfigureServices(IServiceCollection services)
{
	services.AddDbContext<AppDbContext>(options =>
		options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));
	services.AddMvc();
}
```
## Database Seeding
we will create a static class `DbInit` to seed some fake data to the database. Firstly we will check if the database is created or not. If the database
is not created it will do the seedings.
at the end we need to save the changes to the database synchronously or unsynchronusly. 
```csharp
public static class DbInit
{
	public static void InitializeWithFakeData(AppDbContext context)
	{
		// Makes sure that database is created
		// If it is created it does nothing (If it is not created it is going to create a database)
		context.Database.EnsureCreated();

		// Check if the context table contain any data If does not add the fake data
		if (!context.Contacts.Any())
		{
			context.Contacts.Add(new Contact() {FirstName = "Ahmed", LastName = "Smith", Email = "abc@abc.com"});
			context.Contacts.Add(new Contact() {FirstName = "John", LastName = "Smith", Email = "dbc@abc.com"});
		}

		if (!context.ToDos.Any())
		{
			context.ToDos.Add(new ToDo() {Text = "Wash the car", Completed = true});
		}

		context.SaveChanges();
	}
}
```
Now we  need to call this class. We will remove the `BuildWebHost(args).Run();` method and call the host. 
```csharp
public static void Main(string[] args)
{
	var host = BuildWebHost(args);
	using (var newScope=host.Services.CreateScope())
	{
		// Register the context class
		var context = newScope.ServiceProvider.GetRequiredService<AppDbContext>();
		// Call DbInit 
		DbInit.InitializeWithFakeData(context);
	}

	//* NotFORGET
	host.Run();

}
```
the using rapper ensures that the service will be disposed when this part of code. 

Now you can run the project to see if this work.

> Notice: Incase of error make sure to check your DatabaseContext class constructor to be `public`. If it is not public dependency injection cannot initialize it.

## SQL Server Object Explorer
Inside the visual studio, from here you can see you local db and find that the database is created. As you can see Entity Framework
has made the Id field as primary key by convenction. 

>Note: In real life senarios you will have to use migrations. Generally It is not a good idea to delete the whole database  
to change its structure

## Migrations and Why we need them
It is not efficient to drop the database and all its data everytime you need to make a change. Forexample if we have to add the phone number
field to the contact table we need to drop the database and start the application so it could create the database for us. In the production you cannot drop a database
each time when you add extra fields to it. `The only way will be changing the production database manually by SQL commands (Which is a bad idea).` 

If you manually update the production database using SQL command, you have to update the models inside the program manually too.
If one of them fails you database fail to sync with source.
### What are Migrations
- Migrations are files generated by EF Core based on your models.
- Reads your model and created files according to it.
- Migrations keep the models and the database in sync.
- Edit database without losing data.
- Provide a way to Roll Back to previous version.
- It is a version control for your database.

### First Migration
We will use the `Package Manager Console` to execute the migrations.
>Make sure to delete the database before applying migrations

Enable migrations (optional)
```sh
Enable-Migrations
```

add a migration 
```sh
Add-Migration migration_Name 
```
For example
```sh
Add-Migration initial
```

Update the database (Write the changes to the database)
```sh
Update-Database
```


> If you get an eror during the first migration try to install the following packages
```sh
<PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" Version="2.1.4" />
<PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer.Design" Version="1.1.6" />
<PackageReference Include="Microsoft.EntityFrameworkCore.Tools" Version="2.1.4">
```

Each migration is made of two method Up and down.
The up method includes the changes that will be added the db. The down method include what can i roll back after the reset.
We have the DbContextSnapshout class that is essentail should not be modified by the user.


#### Updating a Table
We will update a table in an existing database.
We want to add the phone number to the contact model.
```csharp
public class Contact: BaseEntity
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public string Email { get; set; }
    public string PhoneNumber { get; set; }
}
```

```sh
Add-migration AddContactPhoneNumber
update-database
```
we will Run from package manager console. It is a good idea to use descriptive names.

In DbcontextSnapshout you can see the entityframework has added a new property. `   b.Property<string>("PhoneNumber");`


#### Adding Multiple changes
```csharp
public class ToDo:BaseEntity
{
    [Required]
    public string Text { get; set; }
    [Required]
    public bool Completed { get; set; }
    [Required]
    public DateTime CreatedAt { get; set; }
      
    public DateTime CompletedAt { get; set; }        
}
```
Add-migations and update the database using the commands provided.


### Rolling Back
we have two roll back
- Rolling Back an unapplied migration
- Rolling Back an applied migration

#### Removing an Unapplied Migration
It happens when we have run the add-migration command and we have not run the update-database command.

For example: in the contact model we add `public int adress {get; set;}` and we run the `add-migration`. It will update
our DbContextSnapshot. In this case we want to change the int to string but we have commited a migration we need to roll back that migration
So,

```sh
Remove-migration
```
this command will remove the previous migration (migration was not applied to the database).


#### Removing an Applied Migration
A migration that has been applied to the database. So any changes we have applied are in the database.

For example: we added the address to the contact model and we applied the changes to the database.

To revert to the old migrations 
```sh
Update-Database AddToDoDates

```
Here `AddToDates` is the name of the previous migration. and the address field that we added to the contact model will be no more in the database.


## Creating Models and Connect via Relationships
### Restricting Length
Restricting the length of the string values, It is very easy. 

>From Entity Framework prospective a model is an entity. The word entity comes from the domain driven desing. An entity is 
a mutable object whose values can change but its identity cannot change.

Attributes are present in C# programming language for a long time. It comes before a method, a field or a class, provide extra 
information to the run-time. 

One way is to enhance entities is by using attributes and second way is through the Fluent-API.
Fluent API is not an actual alternative to the attributes methods that means they are not mutually exculsive.
By using fluent API we can also declare alternative keys.

